<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不荒不慌</title>
  
  <subtitle>圆圆圈圈</subtitle>
  <link href="/brickzh/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-04T13:30:47.046Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Brick Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++容器——迭代器使用的一个陷阱</title>
    <link href="http://yoursite.com/2019/04/14/C++%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1/"/>
    <id>http://yoursite.com/2019/04/14/C++容器——迭代器使用的一个陷阱/</id>
    <published>2019-04-14T04:01:56.000Z</published>
    <updated>2019-05-04T13:30:47.046Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在项目开发中遇到一个很诡异的bug：使用迭代器循环删除一个std::set容器里的几个元素，但最后发现容器里的对应元素并没有被删除干净，为了说明这个场景，我们来看一个代码片段，这是我为了重现该问题，弄了的一段测试代码。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numList[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//1.set add</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; numSet;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1insert into set</span></span><br><span class="line">    numSet.insert(numList[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.travese set</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=numSet.begin() ;it!=numSet.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" occurs "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"before delete numSet.size()= "</span>&lt;&lt;numSet.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = numSet.begin(); it != numSet.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"delete "</span> &lt;&lt;*it &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    numSet.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"after delete numSet.size()= "</span>&lt;&lt;numSet.size()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>  这段测试代码的功能很简单，构造一个set容器，把几个数字塞进去，然后通过它的迭代器循环清除里面的元素，大家可以想一下for循环前后的这两句log输出的是什么。</p></li></ul><ul><li><p>这是输出的结果</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before <span class="keyword">delete</span> numSet.size()= <span class="number">3</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span></span><br><span class="line">after <span class="keyword">delete</span> numSet.size()= <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>是不是和你们很多人预想的不太一样，for循环只循环了一次就跳出去了，那说明第一次循环结束再回到for循环条件判断时it!=umSet.end()不成立了，it指向了容器的end，验证一下。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=numSet.begin();(<span class="built_in">cout</span>&lt;&lt; (it == numSet.end() ? <span class="string">"end"</span>:<span class="string">"not end"</span>)&lt;&lt;<span class="built_in">endl</span>, it!=numSet.end());it++) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"delete "</span> &lt;&lt;*it &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    numSet.erase(it);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; (it == numSet.end() ? <span class="string">"end"</span>:<span class="string">"not end"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  输出结果：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before <span class="keyword">delete</span> numSet.size()=<span class="number">3</span></span><br><span class="line"><span class="keyword">not</span> end</span><br><span class="line"><span class="number">1</span> <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">not</span> end</span><br><span class="line">end</span><br><span class="line">after <span class="keyword">delete</span> numSet.size()=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>  确实是这样，在网上查阅了一下使用迭代器删除元素的方法，有两条注意事项：</p><blockquote><p>1.对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前的iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入，删除一个结点不会对其他结点造成影响。</p></blockquote></li><li><p>这样对于关联容器，正确的使用迭代器的方法是这样：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=numSet.begin(); it!=numSet.end());) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"delete "</span> &lt;&lt;*it &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    numSet.erase(it++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.对于序列式容器（如vector，deque，list等），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator。</p></blockquote></li><li>而对于序列容器，正确的方法应该是这样：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=numSet.begin(); it!=numSet.end());) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"delete "</span> &lt;&lt;*it &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    it = numSet.erase(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>就是这么一个很小的点，都怪平时使用的时候太过于理所当然了，迭代器的使用还是要小心，此为记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;在项目开发中遇到一个很诡异的bug：使用迭代器循环删除一个std::set容器里的几个元素，但最后发现容器里的对应元素并没有被删除干净，为了说明这个场景，我们来看一个代码片段，这是我为了重现该问题，弄了的一段测试代码。&lt;/p&gt;
  &lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Wear(Wear OS)开发</title>
    <link href="http://yoursite.com/2019/04/14/Android-Wear-Wear-OS-%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/04/14/Android-Wear-Wear-OS-开发/</id>
    <published>2019-04-14T04:01:56.000Z</published>
    <updated>2019-04-14T04:37:29.080Z</updated>
    
    <content type="html"><![CDATA[<h4 id="——简化Wear版Wx开发过程中的一些总结"><a href="#——简化Wear版Wx开发过程中的一些总结" class="headerlink" title="——简化Wear版Wx开发过程中的一些总结"></a><em>——简化Wear版Wx开发过程中的一些总结</em></h4><h3 id="1-微光模式"><a href="#1-微光模式" class="headerlink" title="1. 微光模式"></a>1. 微光模式</h3><blockquote><p>智能手表的电池容量都比较低，导致续航也比较短。为了延长手表的续航，Wear OS 手表在没有操作一段时间后，会进入微光模式 AmbientMode。微光模式就是一个省电模式，这个模式会在低功耗下运行，默认情况下，手表会离开当前的应用，返回到表盘的界面。但有时候，我们希望开发的应用在某些情况下，可以一直保持可见的状态，这就需要我们使用支持微光模式的 Activity 了。</p></blockquote><ul><li><p>一般wear应用的activity继承自WearableActivity，然后activity里调用setAmbientEnabled()来支持微光模式，但是我们的工程的页面架构是一个activity+多fragment的形式；这要求我们的activity必须继承自FragmentActivity,因而需要使用另一种方式来支持微光模式: HomeActivity继承FragmentActivity，同时实现AmbientModeSupport.AmbientCallbackProvider接口，在onCreate里调用AmbientModeSupport.attach(this)，它返回一个AmbientModeSupport.AmbientController对象，可用于查询当前微光模式所处的状态。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> <span class="keyword">implements</span> <span class="title">AmbientModeSupport</span>.<span class="title">AmbientCallbackProvider</span></span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_home);</span><br><span class="line">    Log.d(TAG, <span class="string">"onCreate"</span>);</span><br><span class="line">    AmbientModeSupport.attach(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AmbientModeSupport.AmbientCallbackProvider定义如下，我们可以实现这些接口，来对微光模式的不同状态进行处理。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AmbientCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AmbientCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnterAmbient</span><span class="params">(Bundle ambientDetails)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpdateAmbient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExitAmbient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAmbientOffloadInvalidated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Wear-OS右划退出"><a href="#2-Wear-OS右划退出" class="headerlink" title="2. Wear OS右划退出"></a>2. Wear OS右划退出</h3><ul><li><p>wear针对穿戴设备的操作特点，有个默认的手势：右划退出当前全屏Activity，这对于一般页面操作很方便，ios和Android应用很多都有类似的支持，但对于手表这种屏幕比较小设备，wear提供的是全屏响应手势的，并不像手机是左侧边缘才响应，这样wear的交互设计上一般不建议再使用水平滑动的手势，但凡事总有例外，我们的应用中就有一个右划的手势操作，解决方案就是使用SwipeDismissFrameLayout来包裹我们的视图，我们的视图需要重写canScrollHorizontally方法，返回true，这时就启动了边缘滑动状态（屏幕左侧10%的位置才相应水平滑动手势）。<br>-<br>  布局文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.wear.widget.SwipeDismissFrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.tencent.ui.voip.SwipeViewContainer</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--我们自己的视图--&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.tencent.ui.voip.SwipeViewContainer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.wear.widget.SwipeDismissFrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自定义View SwipeViewContainer，canScrollHorizontally返回true。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwipeViewContainer</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canScrollHorizontally</span> <span class="params">(<span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>右划退出在实际使用过程中发现一个问题</strong>，被划出的页面（Fragment）退出后又会再闪现了一下，造成很不好的体验，在网上没有找到有用的信息，只能自己摸索。</p><ul><li><p>首先想到的是不是fragment的切换动画引起的， FragmentTransaction定义了如下几种切换方式，但即使设置成TRANSIT_NONE，还是依然会有问题，看来不是切换动画的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIT_ENTER_MASK = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIT_EXIT_MASK = <span class="number">8192</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIT_UNSET = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIT_NONE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIT_FRAGMENT_OPEN = <span class="number">4097</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIT_FRAGMENT_CLOSE = <span class="number">8194</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIT_FRAGMENT_FADE = <span class="number">4099</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后想能不能在fragment切换过程中对旧页面进行一些操作，这就需要对滑动操作的过程进行监听，SwipeDismissFrameLayout类提供了实现的方法，让我们的视图包裹在SwipeDismissFrameLayout里，然后设置回调SwipeDismissFrameLayout.Callback，在事件的回调方法里进行相关处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SwipeDismissFrameLayout.Callback mCallback =</span><br><span class="line">    <span class="keyword">new</span> SwipeDismissFrameLayout.Callback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDismissed</span><span class="params">(SwipeDismissFrameLayout layout)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onDismissed()"</span>);</span><br><span class="line">            <span class="comment">//To do</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwipeStarted</span><span class="params">(SwipeDismissFrameLayout layout)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onSwipeStarted()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwipeCanceled</span><span class="params">(SwipeDismissFrameLayout layout)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onSwipeCanceled()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @LayoutRes <span class="keyword">int</span> layoutid)</span> </span>&#123;</span><br><span class="line">    SwipeDismissFrameLayout swipeLayout = <span class="keyword">new</span> SwipeDismissFrameLayout(getActivity());</span><br><span class="line">    inflatedView = inflater.inflate(layoutid, swipeLayout, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    swipeLayout.addView(inflatedView);</span><br><span class="line">    swipeLayout.addCallback(mCallback);</span><br><span class="line">    <span class="keyword">return</span> swipeLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始想在onDismissed回调里将当期fragment隐藏(如下)，但仍没有任何用处，即使在onSwipeStarted调用没任何作用，最后直接来最暴力的，将当期fragment的View直接设置成GONE，这样闪现的问题就解决了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不行</span></span><br><span class="line">getActivity().getSupportFragmentManager().beginTransaction().hide(curFragment);</span><br><span class="line"><span class="comment">//搞定</span></span><br><span class="line">inflatedView.setVisibility(View.GONE);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-Fragment"><a href="#3-Fragment" class="headerlink" title="3.Fragment"></a>3.Fragment</h3><ul><li><p>应用中多个frament彼此进行切换，要求右划后可以回到上一个fragment，要使用add而不是replace，这里需要操作fragment的回退栈。</p><p><strong>进入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction transaction =  getActivity().getSupportFragmentManager().beginTransaction();</span><br><span class="line">transaction.setCustomAnimations(R.anim.slide_right_in, R.anim.slide_right_out);</span><br><span class="line">transaction.add(R.id.fragment_container, messageListFragment);</span><br><span class="line">transaction.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">transaction.commit();</span><br></pre></td></tr></table></figure><p><strong>回退</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getActivity().getSupportFragmentManager().popBackStack();</span><br></pre></td></tr></table></figure><p>同一个fragment不能重复add，不然会出错，这里需要处理一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (messageFragment.isAdded())&#123;</span><br><span class="line">    transaction.remove(messageFragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用回退的方式进入原来的fragment，是不会调用Fragment的任何生命周期回调的，那我们有时候原页面又需要知道这个操作，比如需要更新一下页面的数据或状态等，那我们就需要手动去监听，那监听源是什么呢，我们想到这里发生改变的全局数据就是我们的回退栈，而FragmentManager刚好也提供监听回退栈变化的listener，我们重写listener里的onBackStackChanged接口，在里面我们找到要进入的fragment，然后主动触发它的生命周期方法，比如onResume。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FragmentManager mgrFragment = getSupportFragmentManager();</span><br><span class="line">mgrFragment.addOnBackStackChangedListener(<span class="keyword">new</span> FragmentManager.OnBackStackChangedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackStackChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FragmentManager manager = getSupportFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (fragmentStackSize &gt; manager.getBackStackEntryCount()) &#123;<span class="comment">//判断是回退操作</span></span><br><span class="line">            <span class="keyword">if</span> (manager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Fragment currFrag = manager.findFragmentById(R.id.fragment_container);</span><br><span class="line">                currFrag.onResume();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fragmentStackSize = manager.getBackStackEntryCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-性能问题"><a href="#4-性能问题" class="headerlink" title="4.性能问题"></a>4.性能问题</h3><p>应用里有用RecycleView来显示列表，列表里有图片，我们使用Glide来显示的，这里需要注意的一点是，在使用Glide的时候，应该在别处对其进行一下初始化，不要在onBindViewHolder里就直接使用，这会导致第一次打开页面很慢。同样道理，onBindViewHolder里用到东西，最好都事先加载好。图片可以根据实际需求进行剪裁，避免使用原图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = <span class="keyword">new</span> RequestOptions();</span><br><span class="line">        options.centerCrop();</span><br><span class="line">        options.override(width, height);</span><br><span class="line">        Glide.with(mContext).load(conversation.getHeadimagepath()).into(holder.avatar);</span><br></pre></td></tr></table></figure></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>以上就是这次这个小项目开发过程中的一些点，并没有高大上的东西，自己做个记录，如果能帮助到你那就更好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;——简化Wear版Wx开发过程中的一些总结&quot;&gt;&lt;a href=&quot;#——简化Wear版Wx开发过程中的一些总结&quot; class=&quot;headerlink&quot; title=&quot;——简化Wear版Wx开发过程中的一些总结&quot;&gt;&lt;/a&gt;&lt;em&gt;——简化Wear版Wx开发过程中的一些
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/04/06/hello-world/"/>
    <id>http://yoursite.com/2019/04/06/hello-world/</id>
    <published>2019-04-06T08:29:55.377Z</published>
    <updated>2019-04-06T08:29:55.377Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
